#Vector:
  can be used as an array or a disjoint set
 
  <vector>
  vector<T> v(size, value);
  operator = vector<T> &;
  
  v.push_back()
  [] will get error when no element
  v.at(i) will throw out_of_range of n
  
  v.front()
  v.back()
  v.pop_back()
  v.reserve(n)
  
-------------------------------------------------------------------------------------------------
set: binary search tree, stores key, ordered by key, key unique
multiset binary search tree, stores key, ordered by key, key not unique
map: binary search tree, stores <key,value>, ordered by key, key unique
multimap: binary search tree, stores <key,value>, ordered by key, key not unique
unordered_set: hash table, stores key, hashed by key, key unique
unordered_multiset: hash table, stores key, hashed by key, key not unique
unordered_map: hash table, stores <key,value>, hashed by key, key unique
unordered_multimap: hash table, stores <key,value>, hashed by key, key not unique
-----------------------------------------------------------------------------------------
#map:
  can be used as an array (store index in the key)
  can use a self-designed struct comp
  
  <map>
  
struct classcomp {
  bool operator() (const char& lhs, const char& rhs) const
  {return lhs<rhs;}
};

  map<char,int,classcomp> fourth;
  map[key] = value;
  map.at(key);
  map.insert(pair<key_trpe, value_type>(key, value));
  map.earase(key); map.erase(iterator);
  map.find(key);  //map.end()
  map.count(key);
  map.lower_bound(key)
  map.upper_bound(key)
  map.equal_range(key) //pair<iterator, iterator>
-------------------------------------------------------------------------------------------
#priority_queue:
  can be used as a binary heap
  in default it is a maximum heap
  
  can use a self-designed struct compare
  <queue>

struct edge {
	int a;
	int b;
	edge(int a1 = 0, int b1 = 0) {a = a1; b = b1;}
};

struct comparator {
	bool operator() (edge e1, edge e2) {
		return e1.b < e2.b; //means e1 will be put behind e2
	}
};
  
  priority_queue <edge, vector<edge>, comparator> pq;
  q.push(element);
  q.pop();
  q.top();
  
